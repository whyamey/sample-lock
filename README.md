# Sample-Lock

C implementation of sample-then-lock fuzzy extractor.

## ⚠️ Warning: Research Purposes Only

This tool is intended for **research and educational purposes only**. It should not be used in production environments or for security-critical applications for the following reasons:

1. The HMAC key is hardcoded in the source code
2. The implementation has not undergone security auditing

If you're considering using this in any application where security matters, you should consult with cryptography experts and implement proper key management.

## Description

Sample-Lock is a command-line utility that provides three main functions:
1. **sample**: Generate random sampling positions
2. **store**: Create HMAC hashes from bitstrings for enrollment.
3. **verify**: Check if a given bitstring matches one of the previously stored values

For zeta-sampling, use the bin files that are generated by the lsh-lock tool. A script exists to convert the files to be compliant with the C implementation.

## Installation

### Building from source

1. Clone this repository:
   ```
   git clone https://github.com/whyamey/sample-lock.git
   cd sample-lock
   ```

2. Build the executable:
   ```
   make
   ```

3. Verify the installation:
   ```
   ./bin/sample-lock
   ```

### Installing dependencies

#### Ubuntu/Debian
```
sudo apt-get install build-essential libssl-dev
```

#### Fedora/RHEL/CentOS
```
sudo dnf install gcc openssl-devel
```

#### macOS (using Homebrew)
```
brew install openssl
```
Note: You may need to specify the OpenSSL path in the Makefile when using macOS.

## Usage

The tool offers three main commands: `generate`, `store`, and `verify`.

### General syntax
```
./bin/sample-lock [command] [options]
```

### Commands

#### Generate lockers
```
./bin/sample-lock generate [options]
```
This generates lockers (by sampling unique positions) and saves them to a binary file.

#### Store HMAC hashes of bitstrings
```
./bin/sample-lock store -b <bitstring_file> [options]
```
This reads bitstrings from a file, computes their HMAC hashes, and stores them for later verification.

#### Verify a bitstring
```
./bin/sample-lock verify -b <bitstring_file> [options]
```
This checks if a given bitstring matches one of the previously stored values.

### Options

- `-p, --positions`: Number of unique positions per locker (default: 128)
- `-l, --lockers`: Number of lockers (ONLY for generate, default: 1000000)
- `-m, --maxbits`: Maximum bitstring length (default: 512)
- `-f, --lockerfile`: Filename for lockers (default: lockers.bin)
- `-b, --bitstring`: Bitstring file to process
- `-o, --storedfile`: Filename for storing/loading HMACs (default: stored_hashes.bin)
- `-k, --cryptokey`: Filename for cryptographic key (default: crypto_key.bin)

## Examples

### Generate lockers
```
./bin/sample-lock generate -p 128 -l 1000000 -f my_lockers.bin
```
This generates 1,000,000 lockers, each with 128 unique positions, and saves them to 'my_lockers.bin'.

### Store bitstring hashes
```
./bin/sample-lock store -b bitstrings.txt -f my_lockers.bin -o stored_hashes.bin
```
This processes each bitstring in 'bitstrings.txt', using the lockers from 'my_lockers.bin', and stores the HMAC hashes in 'stored_hashes.bin'.

### Verify a bitstring
```
./bin/sample-lock verify -b input.txt -f my_lockers.bin -o stored_hashes.bin
```
This checks if the bitstring in 'input.txt' matches any of the stored hashes in 'stored_hashes.bin'.

## Input File Format

### Bitstring file format
- One bitstring per line, with only 0s and 1s (commas and whitespace are ignored) for both `store` and `verify` commands.

## Citation
If you use our work, please cite:
```
@misc{cryptoeprint:2024/100,
      author = {Sohaib Ahmad and Sixia Chen and Luke Demarest and Benjamin Fuller and Caleb Manicke and Alexander Russell and Amey Shukla},
      title = {Fuzzy Extractors are Practical: Cryptographic Strength Key Derivation from the Iris},
      howpublished = {Cryptology {ePrint} Archive, Paper 2024/100},
      year = {2024},
      url = {https://eprint.iacr.org/2024/100}
}
```
